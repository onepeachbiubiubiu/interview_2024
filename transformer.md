## [Transformer面试题(转)](http://zhuanlan.zhihu.com/p/681195398)

1. Transformer为何使用多头注意力机制？（为什么不使用一个头）
2. Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？ （注意和第一个问题的区别）
3. Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？
4. 为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根），并使用公式推导进行讲解
5. 在计算attention score的时候如何对padding做mask操作？
6. 为什么在进行多头注意力的时候需要对每个head进行降维？（可以参考上面一个问题）
7. 大概讲一下Transformer的Encoder模块？
8. 为何在获取输入词向量之后需要对矩阵乘以embedding size的开方？意义是什么？
9. 简单介绍一下Transformer的位置编码？有什么意义和优缺点？
10. 你还了解哪些关于位置编码的技术，各自的优缺点是什么？
11. 简单讲一下Transformer中的残差结构以及意义。
12. 为什么transformer块使用LayerNorm而不是BatchNorm？LayerNorm 在Transformer的位置是哪里？
13. 简答讲一下BatchNorm技术，以及它的优缺点。
14. 简单描述一下Transformer中的前馈神经网络？使用了什么激活函数？相关优缺点？
15. Encoder端和Decoder端是如何进行交互的？（在这里可以问一下关于seq2seq的attention知识）
16. Decoder阶段的多头自注意力和encoder的多头自注意力有什么区别？（为什么需要decoder自注意力需要进行 sequence mask)
17. Transformer的并行化提现在哪个地方？Decoder端可以做并行化吗？
18. 简单描述一下wordpiece model 和 byte pair encoding，有实际应用过吗？
19. Transformer训练的时候学习率是如何设定的？Dropout是如何设定的，位置在哪里？Dropout 在测试的需要有什么需要注意的吗？
20. 引申一个关于bert问题，bert的mask为何不学习transformer在attention处进行屏蔽score的技巧？
21. 请简要介绍 Transformer 模型以及它与传统的神经网络架构（如 RNN 和 LSTM）之间的主要区别。
22. Transformer 模型中的自注意力机制是如何工作的？可以解释一下“缩放点积注意力”吗？
23. 在 Transformer 中，位置编码的作用是什么？为什么要引入位置编码？
24. 请解释 Transformer 的多头注意力是如何实现并同时处理不同的信息子空间的。
25. 在 Transformer 模型中，层归一化（Layer Normalization）和残差连接（Residual Connection）的目的是什么？
26. 为什么 Transformer 模型在处理序列数据方面比传统的 RNN 和 LSTM模型有效率得多？
27. 可以描述一下在 Transformer 模型训练中常用的优化方法和训练技巧吗？
28. 可以给出一些基于 Transformer 模型改进和变体的例子，以及它们的优点是什么吗？（如：BERT、GPT系列）
29. 请讨论一下 Transformer 模型用于序列生成任务（如机器翻译、文本生成）时的输出序列是如何生成的。
30. 在深度学习中，过拟合是一个常见问题。在实际工作中，你是如何防止 Transformer 模型过拟合的？
31. 使用 Transformer 模型时可能会遇到的内存和计算问题有哪些？又是如何解决这些问题的？
32. Transformer 模型对于输入序列的长度有什么限制？如果要处理很长的序列，你会采取什么措施？
33. 在某些情况下，Transformer 模型可能并不是最佳选择。可以讨论一下在什么类型的任务或场景中可能会偏好其他模型而不是 Transformer 吗？
34. Transformer 模型的解释性通常被认为是一个挑战，你是否有什么见解或方法来理解模型的决策过程？
35. 最后，设想你需要在不同的硬件配置上部署 Transformer 模型。你会考虑哪些因素以及可能采用的优化策略？

以下是答案

1. **Transformer 模型介绍及与 RNN/LSTM 的区别**
   Transformer   是一种基于自注意力机制的深度学习架构，它主要由编码器和解码器组成。每个编码器和解码器都由若干个相同的层构成，每层中都包含多头注意力和全连接的前馈网络。Transformer  的关键优势在于自注意力机制，它允许模型直接计算序列中任何两个位置之间的依赖关系，无需通过递归。与 RNN/LSTM  相比，Transformer 可以并行处理序列中的所有元素，这使得训练速度快得多。此外，Transformer  能够更好地处理长距离依赖问题，因为它不像 RNN 或 LSTM 那样受到梯度消失的限制。
2. **自注意力机制**
   自注意力机制允许模型在处理一个序列时对其内部的不同部分进行加权。具体来说，这是通过计算序列中每个元素的点积（query  和 key 的点积）来实现的，再对点积进行缩放（除以 $\sqrt{d_k}$，其中 $d_k$ 是键向量的维度）。然后应用 softmax  函数，将这些数值转换成概率分布形式（attention  weights）。这些概率用来加权相应的值（value）向量，最终的输出是这些加权的总和。通过这种机制，每个序列元素都能够在计算其表示时参考到整个序列的信息。
3. **位置编码**
   由于  Transformer  中缺少任何对输入序列元素顺序的隐式建模（如递归网络中的时间步长），因此需要通过位置编码来给模型提供关于元素位置的信息。通常这种编码是通过将每个位置的正弦和余弦函数的值加到对应的嵌入向量中，这些正弦和余弦函数的频率遵循几何级数，这允许模型即使对于长序列也能区分不同位置。
4. **多头注意力**
   在  Transformer  的上下文中，多头注意力机制指的是并行计算多组自注意力（即头）。每个“头”学习序列的不同方面，这样一来，模型可以同时在不同的子空间学习信息。实际上，这是通过为每个头使用不同的、可学习的线性变换（权重矩阵）来实现的，用以产生相应的  query、key 和 value。每个头的输出然后被拼接，并再次线性变换形成最终的输出。
5. **层归一化和残差连接**
   层归一化是指对每一个子层输出的激活值沿特征维度进行归一化。这有助于稳定训练过程并加快收敛速度。残差连接，又称作残差跳过（skip   connections），是通过将输入直接加到子层的输出上（在层归一化前），这使得即使是更深的网络，每层的梯度也能够更加稳定地传播并且减轻梯度消失的问题。
6. **Transformer 高效的原因**
   由于  Transformer 模型依赖的是自注意力机制，这使得模型可以在处理数据时并行化操作，要知道 RNN 或 LSTM  必须按时间步骤顺序处理数据。此外，自注意力允许模型不受顺序长度限制地对所有位置之间的依赖进行建模，而传统的递归网络在长序列上常常面临着梯度消失或爆炸的问题。
7. **优化方法和训练技巧**
   常见的优化方法包括使用  Adam 优化器，它结合了动量优化和 RMSProp 的优点，能自适应地调整每个参数的学习率。此外，Transformer  模型常采用自定义的学习率调度器，开始时采用学习率预热策略，在训练早期逐渐增加学习率，然后再逐步减少。此外，标签平滑是一种正则化技巧，它通过将标签值从  0 和 1 平滑到一个较小的范围内，避免模型对输出过于自信，增强泛化能力。
8. **改进和变体**
   BERT  是一个在大量文本上预训练的双向 Transformer  编码器，它通过掩蔽语言模型（MLM）和下一句预测（NSP）的任务，利用了上下文两侧的信息，学习了深层次的语言特征。GPT 系列模型则采用了  Transformer 解码器，通过单向语境进行预训练，旨在推动文本生成任务的表现。这些变体捕捉到了不同方面的语言规律，并带来更好的性能。
9. **序列生成**
   在机器翻译等序列生成任务中，Transformer   的解码器采用了逐步解码的方式，每次生成一个元素，并将其反馈为下一步的输入。解码过程常结合贪婪搜索，注意力机制，以及束搜索等方法以提高生成结果的质量。束搜索通过保持一定数量的最佳假设并在每个步骤中展开它们，而不是单一地选择概率最高的选项，以此平衡搜索质量与效率。
10. **防止过拟合**
    为了防止过拟合，可采用不同的策略，如增加数据集规模、数据增强、引入 dropout（在训练时随机丢弃部分神经元），以及正则化方法。另外，还可以使用提早停止来避免在验证集上的性能不再提升时继续训练，从而防止在训练数据上过度拟合。
11. **内存和计算问题**
    Transformer   处理特别长的序列时会遇到内存和计算需求增大的问题，因为自注意力的复杂度与序列长度的平方成正比。为解决这一问题，可以采用各种策略，例如梯度累积（分多个小批次累积梯度后再执行一次参数更新），降低批量大小（减少同步计算的序列数量），或使用16位浮点数进行混合精度训练。这能减少内存使用、加速训练，同时对模型精度的影响微乎其微。
12. **处理长序列**
    对于  Transformer  模型，长序列的处理是一个挑战，特别是对于基于标准自注意力的原始架构。为了解决这一问题，研究人员开发了多种方法，如稀疏化注意力模型（仅在序列中计算一部分注意力权重，如  Reformer 或 Longformer），或者使用内存高效的变换技术，如使用局部窗口或者层次化的注意力。
13. **Transformer 不适宜的任务**
    Transformer   模型可能不适合需要强烈的顺序处理或很短的处理时间的任务。例如，在在线的、低延迟的实时任务（如语音识别的增量解码）中，递归模型或许会是更好的选择。此外，在处理非常长的序列时，如果没有专门的调整，原始的  Transformer 可能效率低下。
14. **解释性**
    尽管  Transformer  强大，但其决策过程往往比较难以解释。注意力权重的可视化是一种常见的方法，它能提供模型在计算每个新的输出元素时关注输入序列哪些部分的视觉线索。此外，可以使用一些工具和技术，如梯度类激活映射（Grad-CAM）或集成梯度，来识别模型做出某一预测的关键输入特征。
15. **部署考虑因素**
    在不同的硬件配置上部署  Transformer  模型时需要考虑到诸如模型尺寸、延迟和吞吐量等方面。考虑到不同的设备可能有不同的内存和计算能力限制，可以采取的优化策略包括模型量化（将32位的浮点数转换为更低位的表示，如8位整数），模型剪枝（去除一些不重要的权重）以及知识蒸馏（训练一个更小的模型来模仿大模型的行为）。这些技术可以在不显著损失性能的情况下显著减少模型的大小和加速推理。